Overview

<img width="591" height="354" alt="image" src="https://github.com/user-attachments/assets/6309387e-e1eb-4883-902c-684c1d2e0d8e" />


SQL stands for Structured Query Language which is a computer language for storing, manipulating and retrieving data stored in a relational database. SQL was developed in the 1970s by IBM Computer Scientists and became a standard of the American National Standards Institute (ANSI) in 1986, and the International Organization for Standardization (ISO) in 1987.

Why SQL?
SQL is widely popular because it offers the following advantages −

Allows users to access data in the relational database management systems.

Allows users to describe the data.

Allows users to define the data in a database and manipulate that data.

Allows to embed within other languages using SQL modules, libraries & pre-compilers.

Allows users to create and drop databases and tables.

Allows users to create view, stored procedure, functions in a database.

Allows users to set permissions on tables, procedures and views.


RDBMS Concepts

What is RDBMS?
RDBMS stands for Relational Database Management System. RDBMS is the basis for SQL, and for all modern database systems like MS SQL Server, IBM DB2, Oracle, MySQL, and Microsoft Access.


A field is a column in a table that is designed to maintain specific information about every record in the table.

A record is also called as a row of data is each individual entry that exists in a table.

<img width="687" height="511" alt="image" src="https://github.com/user-attachments/assets/c12595a4-0692-4366-9cc4-7a6fccefc762" />



Database Normalization
Database normalization is the process of efficiently organizing data in a database. There are two reasons of this normalization process −

Eliminating redundant data, for example, storing the same data in more than one table.

Ensuring data dependencies make sense.


Normalization is the process of organizing data in a database to reduce redundancy (duplication) and improve data integrity.

Here are your prep notes for the first three normal forms.

1. First Normal Form (1NF)
The objective of 1NF is to ensure that every table cell contains a single value and that every record is unique.

Rules:

Atomic Values: Each column must contain only one value (no lists or comma-separated sets).

Unique Columns: Each column must have a unique name.

Primary Key: The table must have a primary key to uniquely identify each row.

Example: If a "Students" table has a Phone_Number column with two numbers in one cell, it violates 1NF. You must split those into separate rows or columns.

2. Second Normal Form (2NF)
To reach 2NF, a table must first be in 1NF. The goal here is to remove "partial dependencies."

Rules:

Must be in 1NF.

No Partial Dependency: All non-key columns must depend on the entire primary key. This is only relevant when you have a Composite Key (a primary key made of two or more columns).

Example: If you have a table with Student_ID and Course_ID as a composite primary key, but you also have a Course_Name column, that column only depends on Course_ID. This is a partial dependency. You should move Course_ID and Course_Name to their own table.

3. Third Normal Form (3NF)
To reach 3NF, a table must be in 2NF. The goal is to remove "transitive dependencies."

Rules:

Must be in 2NF.

No Transitive Dependency: Non-key columns should not depend on other non-key columns. Everything must depend only on the primary key.

Example: In an "Employees" table, if you have Emp_ID (Key), Dept_ID, and Dept_Name. While Dept_Name depends on Emp_ID, it actually depends on Emp_ID through Dept_ID. If the employee leaves, you shouldn't lose the knowledge that a Department ID maps to a Department Name. You should move Department info to a separate table.
